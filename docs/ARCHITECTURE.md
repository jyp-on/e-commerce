# 설계 및 보안 아키텍처 기술서

## A. 시스템 아키텍처

### 기술 스택 선택 및 근거

**Backend: Node.js + Express.js**
- **선택 이유**: 
  - 빠른 개발 속도와 풍부한 생태계
  - JSON/CSV 처리에 최적화된 라이브러리 지원
  - 비동기 처리로 대용량 파일 처리 성능 우수
  - 마이크로서비스 아키텍처로 확장 용이

**Database: PostgreSQL**
- **선택 이유**:
  - 다중 테넌트 지원을 위한 Row Level Security (RLS)
  - JSONB 타입으로 유연한 규칙 저장
  - ACID 트랜잭션으로 금융 데이터 무결성 보장
  - 강력한 인덱싱과 쿼리 최적화

**Container: Docker + Docker Compose**
- **선택 이유**:
  - 개발/운영 환경 일관성 보장
  - 마이크로서비스 확장성
  - 의존성 관리 및 배포 자동화

### DB 스키마 설계

```sql
-- 회사 테이블 (다중 테넌트 지원)
CREATE TABLE companies (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    encryption_key_id VARCHAR(100), -- 암호화 키 참조
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 카테고리 테이블 (유연한 분류 규칙)
CREATE TABLE categories (
    id VARCHAR(50) PRIMARY KEY,
    company_id VARCHAR(50) NOT NULL,
    name VARCHAR(100) NOT NULL,
    keywords JSONB NOT NULL, -- 키워드 배열
    amount_ranges JSONB, -- 금액 구간 조건
    exclude_keywords JSONB, -- 제외 키워드
    priority INTEGER DEFAULT 0, -- 우선순위
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE
);

-- 거래 내역 테이블 (민감한 데이터 암호화)
CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    company_id VARCHAR(50),
    transaction_date TIMESTAMP NOT NULL,
    description TEXT NOT NULL,
    deposit_amount DECIMAL(15,2) DEFAULT 0,
    withdrawal_amount DECIMAL(15,2) DEFAULT 0,
    balance DECIMAL(15,2) NOT NULL,
    branch VARCHAR(100),
    category_id VARCHAR(50),
    is_classified BOOLEAN DEFAULT FALSE,
    encrypted_data JSONB, -- 민감한 데이터 암호화 저장
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE SET NULL,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE SET NULL
);

-- Row Level Security 활성화
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

-- 회사별 데이터 접근 제어 정책
CREATE POLICY company_isolation ON transactions
    FOR ALL USING (company_id = current_setting('app.current_company_id'));
```

## B. 핵심 자동 분류 로직

### 현재 로직 동작 방식

```javascript
// 1. 키워드 기반 매칭
const isMatch = category.keywords.some(keyword => 
    transaction.description.includes(keyword)
);

// 2. 우선순위 기반 분류
// 더 구체적인 키워드가 우선 적용
```

### 확장 가능한 분류 로직 설계

현재 키워드 기반 매칭에 복잡한 조건들이 추가될 경우, 다음과 같은 방식으로 개선하고 확장할 수 있습니다:

#### 1. 규칙 엔진 기반 접근법

**핵심 아이디어**: 단순한 키워드 매칭을 넘어서 다양한 규칙 타입을 도입하여 더 정교한 분류가 가능하도록 합니다.

**규칙 타입들**:
- **제외 규칙 (EXCLUDE)**: 특정 조건이 만족되면 해당 카테고리에서 완전히 제외
- **필수 규칙 (REQUIRE)**: 반드시 만족되어야 하는 조건, 만족하지 않으면 분류 불가
- **부스트 규칙 (BOOST)**: 조건이 만족되면 점수를 올려주는 규칙
- **페널티 규칙 (PENALTY)**: 조건이 만족되면 점수를 낮추는 규칙
- **조건부 규칙 (CONDITIONAL)**: 여러 조건을 조합한 복합 규칙

**우선순위 시스템**: 규칙들을 우선순위 순으로 처리하여, 높은 우선순위 규칙이 먼저 적용되도록 합니다.

#### 2. 다양한 패턴 매칭 방식

- **키워드 패턴**: 기존 방식과 동일하지만 대소문자 구분, AND/OR 연산자 지원
- **정규식 패턴**: 복잡한 텍스트 패턴을 정규식으로 매칭
- **금액 패턴**: 금액 범위, 입금/출금 구분, 평균 금액 대비 비율 등
- **날짜 패턴**: 특정 기간, 요일, 시간대, 계절성 등
- **빈도 패턴**: 특정 기간 내 거래 빈도, 반복 패턴 등
- **조합 패턴**: 여러 패턴을 AND/OR로 조합

#### 3. 점수 기반 분류 시스템

- **가중치 시스템**: 각 규칙에 가중치를 부여하여 중요도 반영
- **신뢰도 시스템**: 각 분류 결과에 신뢰도를 부여하여 불확실성 표현
- **임계값 설정**: 최소 점수나 신뢰도 미달 시 미분류로 처리

#### 4. 머신러닝 기반 확장

- **특성 추출**: 거래 내역에서 의미 있는 특성들을 자동으로 추출
  - 텍스트 특성: 길이, 단어 수, 숫자 포함 여부, 특수문자 등
  - 금액 특성: 금액 크기, 입출금 구분, 평균 대비 비율 등
  - 시간 특성: 시간대, 요일, 계절성 등
  - 키워드 특성: TF-IDF 벡터화로 키워드 중요도 계산
- **앙상블 방식**: 규칙 엔진과 머신러닝 모델의 결과를 결합하여 정확도 향상
- **지속적 학습**: 사용자 피드백을 통해 모델을 지속적으로 개선

#### 5. 실시간 학습 및 개선

- **피드백 수집**: 사용자가 분류 결과를 수정할 때마다 피드백 데이터 수집
- **패턴 분석**: 피드백 데이터를 분석하여 새로운 규칙이나 패턴 발견
- **자동 규칙 생성**: 분석된 패턴을 바탕으로 새로운 분류 규칙 자동 생성
- **모델 재훈련**: 일정량의 피드백이 쌓이면 머신러닝 모델 재훈련

#### 6. 고급 기능들

- **컨텍스트 인식**: 이전 거래 내역이나 회사 특성을 고려한 분류
- **계절성 고려**: 월별, 분기별로 다른 분류 규칙 적용
- **업종별 최적화**: 회사의 업종에 따라 다른 분류 기준 적용
- **실시간 업데이트**: 새로운 거래 패턴이 발견되면 즉시 반영

#### 7. 성능 최적화

- **캐싱 시스템**: 자주 사용되는 분류 결과를 캐시하여 속도 향상
- **병렬 처리**: 여러 거래를 동시에 분류하여 처리량 증가
- **인덱싱**: 데이터베이스 인덱스를 활용하여 검색 속도 개선
- **배치 처리**: 대량의 거래를 묶어서 처리하여 효율성 증대

이러한 방식으로 확장하면 단순한 키워드 매칭을 넘어서 비즈니스 로직에 맞는 정교하고 유연한 분류 시스템을 구축할 수 있습니다.

## C. 보안 강화 방안

### 공인인증서 저장 및 관리

공인인증서와 같은 민감한 정보를 안전하게 관리하기 위해서는 다음과 같은 다층 보안 체계를 구축해야 합니다:

#### 1. 파일 저장 방식

**클라우드 스토리지 활용**
- AWS S3, Google Cloud Storage 등 안전한 클라우드 스토리지 사용
- 서버 로컬 저장소 대신 클라우드 스토리지로 분리하여 보안 강화
- 각 사용자별로 독립된 폴더 구조로 데이터 격리

**파일 암호화**
- 업로드 시점에 즉시 AES-256-GCM 알고리즘으로 파일 암호화
- 암호화된 파일만 스토리지에 저장하여 원본 파일 노출 방지
- 메타데이터에 암호화 알고리즘과 키 정보 기록

#### 2. 암호화 전략

**이중 암호화 구조**
- 애플리케이션 레벨: 사용자별 고유 키로 파일 암호화
- 스토리지 레벨: 클라우드 제공업체의 서버 사이드 암호화
- 전송 레벨: TLS 1.3을 통한 전송 중 암호화

**키 관리**
- AWS KMS(Key Management Service) 활용하여 암호화 키 관리
- 키 생성, 저장, 교체, 삭제를 중앙화된 시스템에서 관리
- 키 접근 권한을 세밀하게 제어하여 무단 접근 방지

#### 3. 비밀번호 보안

**해싱 및 솔팅**
- bcrypt 알고리즘으로 비밀번호 해싱 (솔트 라운드 12회)
- 레인보우 테이블 공격 방지를 위한 솔팅 적용
- 원본 비밀번호는 절대 저장하지 않음

**비밀번호 정책**
- 최소 12자 이상, 특수문자 포함 필수
- 정기적인 비밀번호 변경 정책 적용
- 실패 로그인 시도 제한 및 계정 잠금

#### 4. 접근 제어

**역할 기반 접근 제어 (RBAC)**
- 사용자, 관리자, 감사자 등 역할별 권한 분리
- 최소 권한 원칙 적용으로 필요한 권한만 부여
- 세션 기반 접근 제어로 임시 권한 관리

**다중 인증 (MFA)**
- SMS, 이메일, 앱 기반 2차 인증 필수
- 공인인증서 사용 시 추가 인증 단계 요구
- 비정상적인 접근 시도 시 추가 인증 요구

#### 5. 모니터링 및 감사

**접근 로그 기록**
- 모든 인증서 접근 시도 로그 기록
- 파일 다운로드, 수정, 삭제 작업 추적
- 실시간 이상 탐지 시스템 구축

**정기 보안 감사**
- 월별 보안 정책 준수 여부 점검
- 접근 권한 정기 검토 및 정리
- 외부 보안 전문가를 통한 취약점 진단

#### 6. 재해 복구 및 백업

**암호화된 백업**
- 정기적인 암호화된 백업 생성
- 지리적으로 분산된 백업 저장소 활용
- 백업 데이터 접근 권한 엄격히 제한

**재해 복구 계획**
- 인증서 손실 시 복구 절차 수립
- 키 손실 시 대체 키 생성 및 적용 절차
- 비즈니스 연속성 보장을 위한 복구 시간 목표 설정

#### 7. 법적 준수

**개인정보보호법 준수**
- 공인인증서 정보의 최소 수집 원칙
- 보유 기간 명시 및 자동 삭제 정책
- 사용자 동의 기반 데이터 처리

**금융권 보안 가이드라인**
- 금융권 보안 표준 준수
- 정기적인 보안 인증 획득
- 외부 감사 기관을 통한 보안 검증

이러한 다층 보안 체계를 통해 공인인증서와 같은 민감한 정보를 안전하게 관리할 수 있습니다.

### 보안 아키텍처

```yaml
# 보안 레이어 구성
Security Layers:
  1. Network Security:
    - VPC + Private Subnets
    - Security Groups
    - WAF (Web Application Firewall)
  
  2. Application Security:
    - JWT Authentication
    - Rate Limiting
    - Input Validation
    - SQL Injection Prevention
  
  3. Data Security:
    - Encryption at Rest (AES-256)
    - Encryption in Transit (TLS 1.3)
    - Key Management (AWS KMS)
    - Row Level Security (RLS)
  
  4. Access Control:
    - Role-Based Access Control (RBAC)
    - Multi-Factor Authentication (MFA)
    - Audit Logging
    - Session Management
```

## D. 문제상황 해결책

### 데이터 노출 사고 대응 시나리오

고객사 거래 데이터가 다른 고객사 대시보드에 노출되는 사고가 발생했을 때, 다음과 같은 체계적인 대응 절차를 거쳐야 합니다:

#### 1. 즉시 대응 조치 (0-2시간)

**사고 신고 접수 및 초기 대응**
- 사고 신고를 받은 즉시 사고 대응팀 소집
- 피해 규모와 영향 범위를 빠르게 파악
- 관련 시스템 접근을 즉시 차단하여 추가 피해 방지

**데이터 접근 차단**
- 해당 고객사의 모든 데이터 접근 권한 일시 정지
- 관련 사용자 계정의 세션을 즉시 무효화
- 데이터베이스 연결 및 API 접근을 임시 차단

**고객사 통보**
- 사고 발생 사실을 즉시 해당 고객사에 통보
- 피해 상황과 대응 조치에 대한 상세한 설명 제공
- 추가 정보 수집을 위한 협조 요청

**관련 기관 신고**
- 개인정보보호위원회에 사고 신고 (24시간 이내)
- 금융권의 경우 금융감독원에도 신고
- 필요시 경찰 수사 기관에 신고

#### 2. 원인 분석 방법 (2-24시간)

**접근 로그 분석**
- 최근 24시간 내 모든 데이터베이스 접근 로그 수집
- 사용자별 접근 패턴과 비정상적인 접근 시도 탐지
- IP 주소, 접근 시간, 쿼리 내용 등을 상세 분석

**시스템 설정 검토**
- Row Level Security (RLS) 정책 설정 상태 점검
- 사용자 권한 설정과 역할 기반 접근 제어 검토
- 데이터베이스 연결 설정과 인증 방식 확인

**코드 및 설정 오류 분석**
- 애플리케이션 코드에서 데이터 격리 로직 검토
- 환경 변수나 설정 파일의 오류 확인
- API 엔드포인트의 권한 검증 로직 점검

**사용자 행동 분석**
- 관련 사용자의 최근 활동 내역 조사
- 권한 변경 이력과 계정 생성/수정 로그 확인
- 의도적 유출 가능성과 실수로 인한 노출 구분

#### 3. 재발 방지 대책

**기술적 대책**

**데이터 격리 강화**
- Row Level Security (RLS) 정책 재검토 및 강화
- 각 고객사별 독립적인 데이터베이스 스키마 구축
- API 레벨에서 고객사 식별 및 검증 로직 강화

**접근 제어 시스템 개선**
- 다중 인증 (MFA) 의무화
- 세션 관리 및 타임아웃 정책 강화
- IP 화이트리스트 기반 접근 제한

**모니터링 시스템 구축**
- 실시간 이상 탐지 시스템 도입
- 데이터 접근 패턴 분석 및 알림 시스템
- 정기적인 보안 취약점 스캔 자동화

**관리적 대책**

**보안 정책 수립**
- 데이터 접근 권한 관리 정책 수립
- 정기적인 보안 교육 및 인식 제고 프로그램
- 사고 대응 매뉴얼 작성 및 정기 업데이트

**인력 관리**
- 보안 담당자 지정 및 책임 명확화
- 정기적인 접근 권한 검토 및 정리
- 보안 관련 인센티브 및 제재 체계 구축

**정기 감사 및 점검**
- 월별 보안 정책 준수 여부 점검
- 분기별 외부 보안 전문가를 통한 취약점 진단
- 연간 보안 인증 획득 및 유지

**물리적 대책**

**인프라 보안 강화**
- 데이터센터 물리적 보안 강화
- 네트워크 분리 및 방화벽 정책 강화
- 백업 데이터의 암호화 및 안전한 보관

**비즈니스 연속성 확보**
- 재해 복구 계획 수립 및 정기 테스트
- 데이터 백업 및 복구 절차 표준화
- 비즈니스 중단 시 대체 시스템 구축

#### 4. 사후 관리 및 모니터링

**고객사 지원**
- 피해 고객사에 대한 지속적인 지원 제공
- 데이터 복구 및 시스템 정상화 지원
- 법적 분쟁 해결을 위한 협조

**사고 분석 및 보고**
- 사고 원인과 대응 과정에 대한 상세 분석
- 개선 사항 도출 및 실행 계획 수립
- 경영진 및 이해관계자에게 사고 보고서 제출

**지속적 개선**
- 사고 대응 과정에서 발견된 문제점 개선
- 보안 시스템 및 정책 지속적 업데이트
- 유사 사고 재발 방지를 위한 선제적 조치

이러한 체계적인 대응을 통해 데이터 노출 사고를 효과적으로 해결하고, 향후 유사한 사고의 재발을 방지할 수 있습니다. 